## <div align="center">Representing Information</div>
<div align="center">마지막으로 공부한 날짜 : 2024.02.18</div>
</br></br>

## 정보의 표현

컴퓨터 정보의 종류는 2진수 비트들로 표현된 프로그램 코드(program code)와 데이터(data)가 존재한다.

<br>

### 프로그램 코드 종류

기계어(machine language)

- 기계 코드(machine code)라고도 함

- 컴퓨터 하드웨어 부품들이 이해할 수 있는 언어로서, 2진 비트들로 구성 되어있다.

<br>

### 어셈블리 언어(assembly language)

- 어셈블리 명령어(assembly instruction)라고도 함

- 고급 언어와 기계어 사이의 중간 언어

- 어셈블러(assembler)로 번역되며, 기계어와 일대일 대응

*어셈블러 : 어셈블리 프로그램을 기계어 프로그램으로 번역하는 소프트웨어

<br>

### 고급언어(high-level language)

- 영문자와 숫자로 구성되어 사람이 이해하기 쉬운 언어

- C, C++, PASCAL, FORTRAN, JAVA 등

- 컴파일러(compiler)를 이용하여 기계어로 번역한다.

*컴파일러(compiler) : 고급언어를 기계어로 변환해주는 소프트웨어

<br>

즉, 고급언어는 사용자를 위한 언어이고, 기계어는 컴퓨터가 이해하기 쉬운 언어이다.

<br>

## 고급언어에서 기계어로 변역 과정

ex) z = x + y 일경우

<br>

## #고급 언어

-  z = x + y

<br>

### 어셈블리 언어

- LOAD A, x  (A에 x의 내용을 불러옴)

- ADD  A, y   (A에 Y의 내용을 더함)

- STOR z, A   (z에 A의 내용을 저장)

- 고급 언어에서의 한줄이 3줄로 늘어남.

- 위의 기호인 LOAD, ADD, STOR을 니모닉스(mnemonics)라고 부른다.

*니모닉스(mnemonics) : 명령어가 지정하는 동작을 나타내는 간략화된 기호

<br>


### 기계어

- 001 00101 (LOAD A, x)

- 100 00110 (ADD A, y)

- 010 00111 (STOR z, A)



이러한 과정을 거쳐 고급언어에서 기계어로 변환된다.

<br>

## 기계 명령어의 형식

ex) LOAD A, x = 001 00101

- 001 : 연산코드(op code) 

- CPU가 수행할 연산을 지정해 주는 비트

- 만약 op code의 비트 수가 3이라면, 지정될 수 있는 연산의 최대수는 8개이다. 2의 3승,

- 만약 op code의 비트 수가 4라면, 지정될 수 있는 연산의 최대수는 16개이다. 2의 4승.

- 위의 경우 op code field가 1이므로, LOAD하라는 의미 

- 00101 : 오퍼랜드(operand)

- 연산에 사용될 데이터 혹은 그것이 저장되어 있는 기억장치 주소 (memory address)

- 만약 operand의 비트 수가 5라면, 주소 지정(addressing)할 수 있는 기억 장소의 최대수는 32개이다.  2의 5승,

- 만약 operand의 비트 수가 6이라면, 주소 지정(addressing)할 수 있는 기억 장소의 최대수는 64개이다. 2의 6승.

- 위의 경우 operand field가 5이므로, 기억장치의 5번지의 내용을 읽어 레지스터 A에 불러오라(op code filed : 1)는 의미.

<br>

## 프로그램 코드와 데이터의 기억장치 저장

- 프로그램 코드(명령어)(op code)와 데이터(operand)는 지정된 기억 장소에 저장한다.

- 단어(word) 단위로 저장

- 단어 : 각 기억 장소에 저장되는 정보의 기본 단위로, CPU에 의해 한 번에 처리될 수 있는 비트들의 그룹

- 단어 길이의 예 : 8비트, 32비트, 64비트, 128비트

- 주소지정 단위 : 단어(word) 단위 혹은 바이트(byte) 단위


<br>


 ## 고정 소수점 & 부동 소수점

<br>

컴퓨터에서 실수를 표현하는 방법은 `고정 소수점`과 `부동 소수점` 두가지 방식이 존재한다.

<br>

1. #### 고정 소수점(Fixed Point)

   > 소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식 (정수 + 소수)
   >
   > ```
   > -3.141592는 부호(-)와 정수부(3), 소수부(0.141592) 3가지 요소 필요함
   > ```

   ![고정 소수점 방식](http://tcpschool.com/lectures/img_c_fixed_point.png)

   **장점** : 실수를 정수부와 소수부로 표현하여 단순하다.

   **단점** : 표현의 범위가 너무 적어서 활용하기 힘들다. (정수부는 15bit, 소수부는 16bit)

   <br>

   <br>

2. #### 부동 소수점(Floating Point)

   > 실수를 가수부 + 지수부로 표현한다.
   >
   > - 가수 : 실수의 실제값 표현
   > - 지수 : 크기를 표현함. 가수의 어디쯤에 소수점이 있는지 나타냄

   **지수의 값에 따라 소수점이 움직이는 방식**을 활용한 실수 표현 방법이다.

   즉, 소수점의 위치가 고정되어 있지 않는다.

   ![32비트 부동 소수점](http://tcpschool.com/lectures/img_c_floating_point_32.png)

   **장점** : 표현할 수 있는 수의 범위가 넓어진다. (현재 대부분 시스템에서 활용 중)

   **단점** :  오차가 발생할 수 있다. (부동소수점으로 표현할 수 있는 방법이 매우 다양함)

- 낮은 주소에 명령어(op code)가 쌓이고

- 높은 주소에 데이터(operand)가 쌓인다.

- 하지만, 실질적으로 컴퓨터는 프로그램 코드 영역과 데이터 코드 영역을 구분하지 않는다.
